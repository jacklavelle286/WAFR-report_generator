AWSTemplateFormatVersion: 2010-09-09

Resources:
  dynamodbtable:
    Type: AWS::DynamoDB::Table
    Properties:
      TableName: "wellarchitectedanswers"
      AttributeDefinitions:
        - AttributeName: "WorkloadId"
          AttributeType: "S"
        - AttributeName: "QuestionId"
          AttributeType: "S"
        - AttributeName: "Risk"  # Additional attribute for the GSI
          AttributeType: "S"
      KeySchema:
        - AttributeName: "WorkloadId"
          KeyType: "HASH"
        - AttributeName: "QuestionId"
          KeyType: "RANGE"
      ProvisionedThroughput:
        ReadCapacityUnits: 5
        WriteCapacityUnits: 5
      GlobalSecondaryIndexes:  # Optional: Define a GSI for the Risk attribute
        - IndexName: "RiskIndex"
          KeySchema:
            - AttributeName: "Risk"
              KeyType: "HASH"
          Projection:
            ProjectionType: "ALL"  # Include all attributes in the index
          ProvisionedThroughput:
            ReadCapacityUnits: 1
            WriteCapacityUnits: 1


  PutDynamoDBLambdaRole:
    Type: AWS::IAM::Role
    Properties:
      AssumeRolePolicyDocument:
        Version: "2012-10-17"
        Statement:
          - Effect: "Allow"
            Principal:
              Service: "lambda.amazonaws.com"
            Action: "sts:AssumeRole"
      Description: "Generate report Lambda role."
      Policies:
        - PolicyName: lambda-role-generate-report
          PolicyDocument:
            Version: "2012-10-17"
            Statement:
              - Effect: "Allow"
                Action:
                  - "wellarchitected:GetLensReviewReport"
                  - "wellarchitected:GetWorkload"
                  - "wellarchitected:ListAnswers"
                Resource: "*"
              - Sid: "dynamodbAccess" 
                Effect: "Allow"
                Action: 
                  - "dynamodb:PutItem"
                Resource: 
                  - !Sub "arn:aws:dynamodb:${AWS::Region}:${AWS::AccountId}:table/wellarchitectedanswers"
              - Sid: "Logging"  
                Effect: "Allow"
                Action: 
                  - "logs:CreateLogGroup"
                Resource: 
                  - !Sub "arn:aws:logs:${AWS::Region}:${AWS::AccountId}:*"
              - Sid: "CreateLogStream"  
                Effect: "Allow"
                Action: 
                  - "logs:CreateLogStream"
                  - "logs:PutLogEvents"
                Resource: 
                  - "*"  
      RoleName: put-dynamodb-lambda-role

  GenerateReportLambda:
    Type: AWS::Lambda::Function
    Properties:
      FunctionName: "putDynamoDBLambda"
    
      Code:
        ZipFile: |
          import boto3
          import json
          import logging

          # Initialize logging
          logger = logging.getLogger()
          logger.setLevel(logging.INFO)

          def lambda_handler(event, context):
              logger.info(f"Received event: {json.dumps(event)}")

              # Initialize AWS clients
              wa_client = boto3.client('wellarchitected')
              dynamodb = boto3.resource('dynamodb')
              table = dynamodb.Table('wellarchitectedanswers')  # Ensure this matches your DynamoDB table name

              # Extract workload ID from the event
              workload_id = event['detail']['requestParameters']['WorkloadId']
              logger.info(f"Extracted WorkloadId: {workload_id}")

              try:
                  workload = wa_client.get_workload(WorkloadId=workload_id)
                  lenses = workload['Workload']['Lenses']
                  logger.info(f"Lenses for workload {workload_id}: {lenses}")

                  for lens_alias in lenses:
                      next_token = None
                      while True:
                          # Include the NextToken in the request if it's present
                          if next_token:
                              response = wa_client.list_answers(WorkloadId=workload_id, LensAlias=lens_alias, NextToken=next_token)
                          else:
                              response = wa_client.list_answers(WorkloadId=workload_id, LensAlias=lens_alias)

                          for answer in response['AnswerSummaries']:
                              question_id = answer['QuestionId']
                              selected_choices = answer.get('SelectedChoices', [])
                              notes = answer.get('Notes', '')
                              risk = answer.get('Risk', '')

                              # Filter for high and medium risk questions
                              if risk in ['HIGH', 'MEDIUM']:
                                  table.put_item(
                                      Item={
                                          'WorkloadId': workload_id,
                                          'QuestionId': question_id,
                                          'Risk': risk,
                                          'SelectedChoices': json.dumps(selected_choices),
                                          'Notes': notes
                                      }
                                  )
                                  logger.info(f"Processed {risk} risk answer for question {question_id} for lens {lens_alias} in workload {workload_id}")

                          # Check for a NextToken in the response and break the loop if not present
                          next_token = response.get('NextToken')
                          if not next_token:
                              break

              except Exception as e:
                  logger.error(f"Error processing workload {workload_id}: {str(e)}")
                  return {'statusCode': 500, 'body': json.dumps(f"Error processing workload {workload_id}: {str(e)}")}

              return {'statusCode': 200, 'body': json.dumps(f"Successfully processed high and medium risk questions for workload {workload_id}.")}


      Handler: index.lambda_handler
      Role: !GetAtt PutDynamoDBLambdaRole.Arn 
      Runtime: python3.12
      Timeout: 300

  NewMilestoneRule:
    Type: AWS::Events::Rule
    Properties:
      Description: "Trigger Lambda function for new milestone in WAR Tool"
      EventBusName: default
      EventPattern:
        source:
          - "aws.wellarchitected"
        "detail-type":
          - "AWS API Call via CloudTrail"
        detail:
          eventSource:
            - "wellarchitected.amazonaws.com"
          eventName:
            - "CreateMilestone"
          requestParameters:
            WorkloadId:
              - exists: true
            MilestoneName:
              - exists: true

      State: "ENABLED"
      Targets:
        - Arn: !GetAtt GenerateReportLambda.Arn
          Id: "GenerateInitialReportRule"

  
  LambdaInvokePermission:
    Type: AWS::Lambda::Permission
    Properties:
      FunctionName: !GetAtt GenerateReportLambda.Arn
      Action: "lambda:InvokeFunction"
      Principal: "events.amazonaws.com"
      SourceArn: !GetAtt NewMilestoneRule.Arn
    DependsOn:
      - NewMilestoneRule
      - GenerateReportLambda

